import {
    collection,
    doc,
    getDocs,
    addDoc,
    updateDoc,
    deleteDoc,
    query,
    orderBy,
    onSnapshot,
    writeBatch,
    getDoc,
    setDoc,
    serverTimestamp,
    Timestamp
} from 'firebase/firestore';
import { db } from '../lib/firebase';
import { Product } from '../types';

const COLLECTION_NAME = 'products';

export const productService = {
    // Get all products
    getAll: async (): Promise<Product[]> => {
        try {
            const q = query(collection(db, COLLECTION_NAME), orderBy('name', 'asc'));
            const querySnapshot = await getDocs(q);
            return querySnapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            } as Product));
        } catch (error) {
            console.error('Error getting products:', error);
            throw error;
        }
    },

    // Subscribe to real-time updates
    subscribe: (callback: (products: Product[]) => void) => {
        const q = query(collection(db, COLLECTION_NAME), orderBy('name', 'asc'));
        return onSnapshot(q, (snapshot) => {
            const products = snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            } as Product));
            callback(products);
        }, (error) => {
            console.error('Error subscribing to products:', error);
        });
    },

    // Add a new product (supports custom ID)
    add: async (product: Product | Omit<Product, 'id'>): Promise<Product> => {
        try {
            // Clean undefined fields
            const data = JSON.parse(JSON.stringify(product));
            const id = (product as any).id;

            if (id) {
                // Use provided ID with setDoc
                const docRef = doc(db, COLLECTION_NAME, id);
                await setDoc(docRef, {
                    ...data,
                    createdAt: serverTimestamp(),
                    updatedAt: new Date().toISOString(),
                    _version: 1
                });
                return { id, ...product } as Product;
            } else {
                // Auto-generate ID with addDoc
                const docRef = await addDoc(collection(db, COLLECTION_NAME), {
                    ...data,
                    createdAt: serverTimestamp(),
                    updatedAt: new Date().toISOString(),
                    _version: 1
                });
                return { id: docRef.id, ...product } as Product;
            }
        } catch (error) {
            console.error('Error adding product:', error);
            throw error;
        }
    },

    // Update a product
    update: async (id: string, updates: Partial<Product>): Promise<void> => {
        try {
            const docRef = doc(db, COLLECTION_NAME, id);
            const data = JSON.parse(JSON.stringify(updates));
            delete data.id; // Don't update ID

            // Use setDoc with merge instead of updateDoc to allow "Upsert"
            // This prevents "No document to update" errors if the doc is missing in DB but exists in UI
            await setDoc(docRef, {
                ...data,
                updatedAt: new Date().toISOString(),
            }, { merge: true });
        } catch (error) {
            console.error('Error updating product:', error);
            throw error;
        }
    },

    // Delete a product
    delete: async (id: string): Promise<void> => {
        try {
            await deleteDoc(doc(db, COLLECTION_NAME, id));
        } catch (error) {
            console.error('Error deleting product:', error);
            throw error;
        }
    },

    // Batch create/import (for migration)
    batchCreate: async (products: Product[]): Promise<number> => {
        try {
            const batch = writeBatch(db);
            let count = 0;
            const CHUNK_SIZE = 450; // Firestore batch limit is 500

            // Process in chunks
            for (let i = 0; i < products.length; i += CHUNK_SIZE) {
                const chunk = products.slice(i, i + CHUNK_SIZE);
                const currentBatch = writeBatch(db);

                chunk.forEach(product => {
                    // Use specific ID if provided in migration, or generate new
                    // For consistency with Sheets, we might want to keep IDs if they are UUIDs
                    const docRef = doc(collection(db, COLLECTION_NAME));
                    // Note: If we want to preserve IDs from Sheets (if they are good UUIDs), we would use:
                    // const docRef = doc(db, COLLECTION_NAME, product.id);
                    // But Sheets often has varied ID formats, so letting Firebase gen IDs might be safer
                    // UNLESS these IDs are referenced in orders.

                    // CRITICAL: We MUST preserve IDs if they are referenced in Orders/Purchases
                    // Assuming Sheets IDs are stable UUIDs generated by IdGenerator.product()
                    const finalDocRef = product.id ? doc(db, COLLECTION_NAME, product.id) : doc(collection(db, COLLECTION_NAME));

                    const data = JSON.parse(JSON.stringify(product));
                    delete data.id; // ID is key

                    currentBatch.set(finalDocRef, {
                        ...data,
                        createdAt: serverTimestamp(),
                        updatedAt: new Date().toISOString(),
                        _version: 1
                    });
                    count++;
                });

                await currentBatch.commit();
            }

            return count;
        } catch (error) {
            console.error('Error batch creating products:', error);
            throw error;
        }
    }
};
